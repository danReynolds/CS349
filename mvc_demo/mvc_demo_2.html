<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>MVC demo 2</title>
</head>
<body>

<div id="app">
    <div>
        Your current excitement level is: <span id="excitement_span">1</span>
    </div>

    <div>
        Set your excitement level: <input type="range" id="excitement_slider"/>
    </div>
</div>

<div style="margin-top: 40px;">
    <a href="mvc_demo_1.html">Previous demo (MVC 1)</a>
    <a href="mvc_demo_3.html">Next demo (MVC 3)</a>
</div>

<!--
    Underscore will create a variable named _ that will provide a bunch of functionality.
    We'll use its functional aspects
-->
<script src="ext/underscore.js"></script>
<script>
    // Simple MVC

    /*
    In this code, we'll make a VERY simple MVC application.

    We'll define a model that represents your excitement level. Then, we'll
    register listeners with that model, which are called whenever it changes.
     */

    // First, we'll define our model:
    var ExcitementModel = function() {
        this.listeners = [];
        this.excitement = 1;

        this.setExcitement = function(value) {

            // Transform value to a number, if it's not already
            this.excitement = parseInt(value) || 1;

            // Notify our listeners
            // Save a reference to this for the function call below
            var model = this;
            // Use underscore to iterate over all listeners, calling each in turn
            _.each(
                this.listeners,
                function(listener_fn) {
                    listener_fn(model, model.excitement);
                }
            );
        };

        this.getExcitement = function() {
            return this.excitement;
        };

        // Signature for listener_fn: (model, newValue)
        this.addListener = function(listener_fn) {
            this.listeners.push(listener_fn);
        };
    };

    window.addEventListener('load', function() {
        // New: Now creating a model for tracking excitement
        var excitementModel = new ExcitementModel();

        var excitementSpan = document.getElementById('excitement_span');
        // Init the span to the model's value
        excitementSpan.innerText = excitementModel.getExcitement();

        var excitementSlider = document.getElementById('excitement_slider');
        excitementSlider.min = 1;
        excitementSlider.max = 11;
        excitementSlider.value = excitementModel.getExcitement();

        // Now, rather than responding directly to changes in the slider, we'll update
        // the model
        excitementSlider.addEventListener('input', function() {
            excitementModel.setExcitement(excitementSlider.value);
        });

        // And we'll register a listener with the model to update the span and
        // the slider when the model changes.
        // Why do we also update the slider? In the next demo, something else may
        // update the model, so we need to keep in sync with it
        excitementModel.addListener(function(model, newValue) {
            excitementSpan.innerText = newValue;
            if (excitementSlider.value != newValue) {
                excitementSlider.value = newValue;
            }
        });
    });
    /*
    What does this buy us? At first glance, not a lot: There is more code, and more layers
    of indirection. However, what it does is start to separate concerns: The data
    is maintained in a separate class, and our view code simply listens to changes in that
    model.

    This means that we can change the model data in any way we want, and the view will respond
    accordingly. We'll demo that next in mvc_demo_3.html
     */

    // Original author: Michael Terry (mterry@cs.uwaterloo.ca)
</script>
</body>
</html>